package writer

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/rancher/sbombastic/internal/database/sqlc"
)

type VulnerabilityReportWriter struct {
	db      *pgxpool.Pool
	queries *sqlc.Queries
}

// NOTE: Keep this struct lightweight; the pgx pool is concurrencyâ€‘safe.

// NewVulnerabilityReportWriter constructs a VulnerabilityReportWriter bound to a pgx connection
// pool. Keeping this in a helper allows easy injection/mocking in
// tests.
func NewVulnerabilityReportWriter(pool *pgxpool.Pool) *VulnerabilityReportWriter {
	return &VulnerabilityReportWriter{db: pool, queries: sqlc.New(pool)}
}

// Create inserts (name, namespace, rawJSON) into the vulnerabilityreports table.
// The SQL is generated by sqlc; ensure your query is annotated as
// `-- name: CreateVulnerabilityReport :execresult` so that it returns a CommandTag.
func (w *VulnerabilityReportWriter) Create(ctx context.Context, name, namespace string, raw []byte) (int64, error) {
	tag, err := w.queries.CreateVulnerabilityReport(ctx, sqlc.CreateVulnerabilityReportParams{
		Name:      name,
		Namespace: namespace,
		Object:    string(raw),
	})
	if err != nil {
		return 0, fmt.Errorf("create vulnerability report: %w", err)
	}
	return tag.RowsAffected(), nil
}

// Delete deletes the vulnerabilityreport from the database and returns the deleted object data.
func (w *VulnerabilityReportWriter) Delete(ctx context.Context, name, namespace string) ([]byte, error) {
	vulnReport, err := w.queries.DeleteVulnerabilityReport(ctx, sqlc.DeleteVulnerabilityReportParams{
		Name:      name,
		Namespace: namespace,
	})
	if err != nil {
		return nil, fmt.Errorf("delete vulnerability report: %w", err)
	}
	return []byte(vulnReport.Object), nil
}

// Get retrieves a vulnerabilityreport from the database.
func (w *VulnerabilityReportWriter) Get(ctx context.Context, name, namespace string) (string, error) {
	vulnReport, err := w.queries.GetVulnerabilityReport(ctx, sqlc.GetVulnerabilityReportParams{
		Name:      name,
		Namespace: namespace,
	})
	if err != nil {
		return "", fmt.Errorf("get vulnerability report: %w", err)
	}
	return vulnReport.Object, nil
}

// List retrieves all vulnerabilityreports from the database.
func (w *VulnerabilityReportWriter) List(ctx context.Context, namespace string) ([]string, error) {
	var vulnReports []sqlc.Vulnerabilityreport
	var err error

	if namespace == "" {
		vulnReports, err = w.queries.ListVulnerabilityReport(ctx)
	} else {
		vulnReports, err = w.queries.ListVulnerabilityReportByNamespace(ctx, namespace)
	}
	if err != nil {
		return nil, fmt.Errorf("list vulnerability reports: %w", err)
	}

	var objects []string
	for _, vulnReport := range vulnReports {
		objects = append(objects, vulnReport.Object)
	}
	return objects, nil
}

// Update updates a vulnerabilityreport in the database.
func (w *VulnerabilityReportWriter) Update(ctx context.Context, name, namespace string, raw []byte) (int64, error) {
	err := w.queries.UpdateVulnerabilityReport(ctx, sqlc.UpdateVulnerabilityReportParams{
		Object:    string(raw),
		Name:      name,
		Namespace: namespace,
	})
	if err != nil {
		return 0, fmt.Errorf("update vulnerability report: %w", err)
	}
	return 1, nil // UpdateVulnerabilityReport doesn't return rows affected, so we assume 1
}

// Count returns the number of vulnerabilityreports in the database.
func (w *VulnerabilityReportWriter) Count(ctx context.Context, namespace string) (int64, error) {
	var vulnReportCount int64
	var err error
	if namespace == "" {
		vulnReportCount, err = w.queries.CountVulnerabilityReport(ctx)
	} else {
		vulnReportCount, err = w.queries.CountVulnerabilityReportByNamespace(ctx, namespace)
	}
	if err != nil {
		return 0, fmt.Errorf("count vulnerability reports: %w", err)
	}
	return vulnReportCount, nil
}
