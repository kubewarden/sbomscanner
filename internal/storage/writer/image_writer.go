package writer

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/rancher/sbombastic/internal/database/sqlc"
)

type ImageWriter struct {
	db      *pgxpool.Pool
	queries *sqlc.Queries
}

// NOTE: Keep this struct lightweight; the pgx pool is concurrencyâ€‘safe.

// NewImageWriter constructs an ImageWriter bound to a pgx connection
// pool. Keeping this in a helper allows easy injection/mocking in
// tests.
func NewImageWriter(pool *pgxpool.Pool) *ImageWriter {
	return &ImageWriter{db: pool, queries: sqlc.New(pool)}
}

// Create inserts (name, namespace, rawJSON) into the images table.
// The SQL is generated by sqlc; ensure your query is annotated as
// `-- name: CreateImage :execresult` so that it returns a CommandTag.
func (w *ImageWriter) Create(ctx context.Context, name, namespace string, raw []byte) (int64, error) {
	tag, err := w.queries.CreateImage(ctx, sqlc.CreateImageParams{
		Name:      name,
		Namespace: namespace,
		Object:    string(raw),
	})
	if err != nil {
		return 0, fmt.Errorf("create image: %w", err)
	}
	return tag.RowsAffected(), nil
}

// Delete deletes the image from the database and returns the deleted object data.
func (w *ImageWriter) Delete(ctx context.Context, name, namespace string) ([]byte, error) {
	image, err := w.queries.DeleteImage(ctx, sqlc.DeleteImageParams{
		Name:      name,
		Namespace: namespace,
	})
	if err != nil {
		return nil, fmt.Errorf("delete image: %w", err)
	}
	return []byte(image.Object), nil
}

// Get retrieves an image from the database.
func (w *ImageWriter) Get(ctx context.Context, name, namespace string) (string, error) {
	image, err := w.queries.GetImage(ctx, sqlc.GetImageParams{
		Name:      name,
		Namespace: namespace,
	})
	if err != nil {
		return "", fmt.Errorf("get image: %w", err)
	}
	return image.Object, nil
}

// List retrieves all images from the database.
func (w *ImageWriter) List(ctx context.Context, namespace string) ([]string, error) {
	var images []sqlc.Image
	var err error

	if namespace == "" {
		images, err = w.queries.ListImages(ctx)
	} else {
		images, err = w.queries.ListImagesByNamespace(ctx, namespace)
	}
	if err != nil {
		return nil, fmt.Errorf("list images: %w", err)
	}

	var objects []string
	for _, image := range images {
		objects = append(objects, image.Object)
	}
	return objects, nil
}

// Update updates an image in the database.
func (w *ImageWriter) Update(ctx context.Context, name, namespace string, raw []byte) (int64, error) {
	err := w.queries.UpdateImage(ctx, sqlc.UpdateImageParams{
		Object:    string(raw),
		Name:      name,
		Namespace: namespace,
	})
	if err != nil {
		return 0, fmt.Errorf("update image: %w", err)
	}
	return 1, nil // UpdateImage doesn't return rows affected, so we assume 1
}

// Count returns the number of images in the database.
func (w *ImageWriter) Count(ctx context.Context, namespace string) (int64, error) {
	var imageCount int64
	var err error
	if namespace == "" {
		imageCount, err = w.queries.CountImages(ctx)
	} else {
		imageCount, err = w.queries.CountImagesByNamespace(ctx, namespace)
	}
	if err != nil {
		return 0, fmt.Errorf("count images: %w", err)
	}
	return imageCount, nil
}
